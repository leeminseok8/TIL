## 💡 Better Way14: 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라

list 내장 타입에는 리스트의 원소를 기준에 따라 정렬할 수 있는 sort 메소드가 들어 있다. 기본적으로 sort는 리스트의 내용을 원소 타입에 따른 자연스러운 순서를 사용해 오른차순으로 정렬한다.

sort 메서드는 자연스럽게 순서를 정할 수 있는 대부분의 내장 타입(문자열, 부동소수점 수 등)에 대해 잘 동작한다. 하지만 객체는 어떻게 처리할까?

```
class Tool:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __repr__(self):
        return (f'Tool({self.name!r}, {self.weight})')

tools = [
    Tool('차단기', 3.5),
    Tool('해머', 2.5),
    Tool('깽폼', 10),
    Tool('크레인', 10)
]
```

sort 메서드가 호출하는 객체 비교 특별 메서드가 정의돼 있지 않으므로 이런 타입의 객체는 정렬할 수 없다.

> 정렬에 사용하고 싶은 애트리뷰트가 객체에 들어 잇는 경우가 많다. 이런 상황을 지원하기 위해 sort에는 key라는 파라미터가 있다. key는 함수여야 하고, key 함수에는 정렬 중인 리스트의 원소가 전달된다. key 함수가 반환하는 값은 원소 대신 정렬 기준으로 사용할, 비교 가능한(즉, 자연스러운 순서가 정의된) 값이어야만 한다.

다음 예제에는 lambda 키워드로 함수를 정의했다.

```
print('미정렬', repr(tools))
tools.sort(key=lambda x:x.name)
print('/n정렬', tools)
```

이 함수를 key로 사용하면 Tool 객체로 이뤄진 리스트를 이름(name)에 따라 알파뱃순으로 정렬한다. 원소 어트리뷰트에 접근하거나 인덱스를 써서 값을 얻거나(원소가 시퀀스, 튜플, 딕셔너리인 경우) 다른 모든 식을 사용할 수 있다.

### 여러 기준
때로는 여러 기준을 사용해 정렬해야 할 수도 있다. 예를 들어, weight로 먼저 정렬한 다음에 name으로 정렬하고 싶다면 어떻게 해야 할까?

가장 쉬운 방법은 튜플 타입을 쓰는 것이다. 튜플은 기본적으로 비교 가능하며 자연스러운 순서가 정해져 있다. 비교하는 두 튜플의 첫 번째 위치의 값이 같은면 두 번째, 세 번째 계속 비교를 반복한다.

```
tools.sort(key=lambda x:(x.weight, x.name))

>>>
[Tool('해머', 2.5), Tool('차단기', 3.5), Tool('깽폼', 10)], Tool('크레인', 10)
```

위의 코드처럼 어트리뷰트의 우선순위에 따라 튜플에 넣어 반환하는 key 함수이다. (앞에부터 순서 존재 : weight -> name) sort 메서드에 reverse 파라미터를 True로 적용하면 두 기준의 정렬 순서가 똑같이 영향을 받고, 단항 부호 반전(-) 연산자를 사용해 정렬 방향을 혼합할 수도 있다. (이 경우, 모든 타입에는 사용할 수 없다.)

```
tools.sort(key=lambda x:(x.weight, -x.name))

>>>
TypeError: bad operand type for unary -: 'str'
```

파이썬에서는 이런 상황을 위해 안정적인 정렬 알고리즘을 제공한다. sort 메서드는 key 함수가 반환하는 값이 서로 같은 경우 리스트에 들어 있던 원래 순서를 그대로 유지해준다. 즉 같은 리스트에서 다른 기준으로 sort를 여러 번 호출해도 된다는 의미이다.

```
tools.sort(key=lambda x:x.name)

tools.sort(key=lambda x:x.weight, reverse=True)

>>>
[Tool('깽폼', 10), Tool('크레인', 10), Tool('차단기', 3.5), Tool('해머', 2.5)]
```

위와 같은 접근 방법을 사용하면 여러 다른 타입의 정렬 기준을 원하는 방향으로 서로 조합할 수 있다. **다만, 얻고 싶은 정렬 기준 우선순위의 역순으로 정렬해야 한다.**

꼭 필요한 경우가 아니라면 단항 부호 반전 연산자를 활용하는 것이 좋고, 꼭 필요할 때만 sort를 여러 번 호출하는 방법을 사용하는 것이 좋다.