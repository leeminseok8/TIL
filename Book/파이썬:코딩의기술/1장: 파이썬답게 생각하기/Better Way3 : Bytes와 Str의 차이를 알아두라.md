## 💡 Better Way3 : Bytes와 Str의 차이를 알아두라

파이썬에서 문자열 데이터의 시퀀스를 표현하는 두 가지 타입이 있다. bytdes와 str이다.bytes타입 인스턴스는 8바이트 데이터가 그대로 들어가고 str인스턴스는 사람이 사용하는 언어의 문자를 표현하는 유니코드 코드 포인트가 들어 있다.

중요한 사실은 str과 bytes는 서로 대응하는 인코딩이 없다. 유니코드 데이터를 이진 데이터로 변환하려면 str의 encode 메서드를 호출해야 하고, 반대의 경우에는 bytes의 decode 메서드를 호출해야 한다. 원하는 인코딩 방식을 명시적으로 지정할 수도 있고, 시스템 디폴트 인코딩을 받아들일 수도 있다. 일반적으로 UTF-8이 시스템 디폴트 인코딩 방식이다.

문자를 표현하는 타입이 둘로 나뉘어 있어 파이썬 코드에서는 두 가지 상황이 자주 발생한다.

- UTF-8로 인코딩된 8비트 시퀀스를 그대로 사용하고 싶다.

- 특저어 인코딩을 지정하지 않은 유니코드 문자열을 사용하고 싶다.

두 경우를 원하는 값과 일치하는지 확신하기 위해 종종 두 가지 도우미 함수가 필요하다.

첫 번째 함수는 bytes나 str 인스턴스를 받아서 항상 str을 반환한다.
```
def to_str(bytes_or_str):
    if isinstance(bytes_or_str, bytes):
        value = bytes_or_str.decode('utf-8')
    else:
        value = bytes_or_str
    return value
```

두 번째는 bytes나 str 인스턴스를 받아서 bytes를 반환할 수 있다.(encode 사용)

---

<br>

이진 8비트 값과 유니코드 문자열을 파이썬에서 다룰 때 꼭 기억해야 할 두 가지 문제가 있다.

첫 번재는 bytest와 str이 똑같이 작동하는 것처럼 보이지만 각자의 인스턴스는 서로 호환되지 않기 때문에 전달중인 문자 시퀀스가 어떤 다팁인지를 항상 잘 알고 있다야 한다는 것이다.

같은 타입의 인스턴스일 경우 + 연산자를 사용하면 더할 수 있다.

```
print(b'one' + b'two')
print('one' + 'two')

>>>
b'onetwo'
onetwo
```
물론 다른 타입의 인스턴스는 더할 수 없다.

또한, 이항연산자나 등호, %형식화 문자열에 대해 작동한다.

```
print(b'red %s' % 'blue')
>>> TypeError
```

str 형식화 문자열에 bytes 인스턴스를 넘길 수는 있지만, 이 경우에는 예상과 다르게 작동한다.

```
print('red %s' % b'blue')
>>> red b'blue'
```
이 코드는 실제로 bytes 인스턴스의 __ repr __메서드를 호출한 결과로 %s를 대신한다.

두 번째 문제점은 파일 핸들과 관련한 연산들이 디폴트로 유니코드 문자열을 요구하고 이전 바이트 문자열을 요구하지 않는다는 것이다. 예를 들어 이진 데이터를 파일에 기록하고 싶다고 하자. 다음과 같은 코드도 오류가 발생한다.

```
with open('data.bin', 'w') as f:
    f.write(b'\f1\xf2\xf3\xf4')
>>> TypeError: write() argument must be str, not bytes
```

예외가 발생한 이유는 파일을 열 때 이진 쓰기 모드('wb')가 아닌 텍스트 쓰기 모드('w')로 열었기 때문이다. 파일이 텍스트 모드인 경우 write 연산은 유니코드 데이터가 들어있는 str 인스턴스를 요구한다. 이 문제는 'wb' 모드를 사용하면 해결할 수 있다.

파일에서 데이터를 읽어올 때도 비슷한 문제가 발생할 수 있다.

```
with open('data.bin', 'r') as f:
    data = f.read()
>>> UnicodeDecodeError: 'utf-8' codec can't decode
```

위의 경우 파일을 열 때 'rb'가 아닌 'r'(텍스트 모드)로 열었기 때문이다. 핸들이 텍스트 모드에 있으면 bytes.encode('w') / str.decode('r')에 적용해서 이진 데이터를 해석한다. 대부분 시스템에서 디폴트 인코딩은 'utf-8'인데 이 때 인코딩은 이진데이터를 읽을 수 없어 오류가 발생한다. 그래서 'rb' 모드로 열면 해결 가능하다.

다른 방법으로 open 함수의 encoding 파라미터를 명시하면 해결할 수 있다. 예를 들어 이진 데이터가 as100으로 돼 있다고 가정하자.

```
with open('data.bin', 'r', eccode='as100') as f:
    data = f.read()
```

파일의 내용을 문자열로 해석한 내용은 기존 이진 데이터를 읽었을 때 반환됐던 것과 다른 값이다. 여기서 다음 사실을 알 수 있다. 예상하는 것과 시스템의 디폴트 인코딩이 어떻게 다른지 이해하기 위해 시스템 인코딩을 항상 검사해야 한다는 것이다.(python3 -c 'import locale; print(locale.getpreferredencoding())') 디폴트 인코딩이 의심스러운 경우에는 명시적으로 open에 eccoding 파라미터를 전달해야 한다.

---

### 기억해야 할 내용
- 처리할 입력이 원하는 문자 시퀀스인지 확실히 하려면 도우미 함수를 사용하라.
- bytes와 str 인스턴스를 연산자에 섞어서 사용할 수 없다.
- 이진 데이터를 파일에서 읽거나 파일로 쓰고 싶으면 항상 이진모드로 파일을 열어라.
- 유니코드 데이터를 파일에서 읽거나 파일에 쓰고 싶을 때는 시스템 디폴트 인코딩에 주의하자. open에 encoding 파라미터를 명시적으로 전달하라.